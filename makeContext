#!python3

import os
import sys
import time
import re
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

# Mapping of file extensions to Markdown code syntax specifiers
syntax_highlighting = {
    '.swift': 'swift',
    '.py': 'python',
    '.js': 'javascript',
    '.ts': 'typescript',
}

# List of regexes for prioritizing specific files
priority_files = [r"STARTHERE"]

# List of regexes for omitting specific files
omit_files = [r".*\.(png|jpg|jpeg|gif|svg)"]

class ChangeHandler(FileSystemEventHandler):
    def __init__(self, directory, output_file, process_func):
        self.directory = directory
        self.output_file = output_file
        self.process_func = process_func

    def on_any_event(self, event):
        # Ignoring changes to the output file itself
        if self.output_file and os.path.abspath(event.src_path) == os.path.abspath(self.output_file):
            return
        self.process_func(self.directory, self.output_file)

def list_files_and_contents(directory, output_file=None):
    top_level_directory = os.path.basename(directory.rstrip(os.sep))
    all_paths = []
    priority_paths = []
    omitted_paths = []
    for root, dirs, files in os.walk(directory, topdown=True):
        # Remove directories that start with '.'
        dirs[:] = [d for d in dirs if not d.startswith('.')]
        files = [f for f in files if not f.startswith('.')]
        for filename in files:
            full_path = os.path.join(root, filename)
            if any(re.search(pattern, filename) for pattern in priority_files):
                priority_paths.append(full_path)
            elif any(re.search(pattern, filename) for pattern in omit_files):
                omitted_paths.append(full_path)
            else:
                all_paths.append(full_path)

    # Prioritize certain files by moving them to the front
    all_paths = priority_paths + all_paths
    all_paths.sort(key=lambda x: (x not in priority_paths, x))

    output_lines = [f"# {top_level_directory}\n\n"]
    for path in all_paths + omitted_paths:
        relative_path = os.path.relpath(path, directory)
        file_extension = os.path.splitext(path)[1]
        syntax_specifier = syntax_highlighting.get(file_extension, '')
        if path in omitted_paths:
            output_lines.append(f"## {relative_path}\n\n*OMITTED*\n\n")
        else:
            output_lines.append(f"## {relative_path}\n\n```{syntax_specifier}\n")
            try:
                with open(path, 'r') as file:
                    content = file.read()
                    if content.endswith('\n'):
                        output_lines.append(content.rstrip('\n') + '\n```\n\n')
                    else:
                        output_lines.append(content + '\n```\n\n')
            except Exception as e:
                output_lines.append(f"Error reading file {relative_path}: {e}\n```\n\n")

    if output_file:
        with open(output_file, 'w') as f:
            f.writelines(output_lines)
    else:
        print(''.join(output_lines))

def main():
    output_file = None
    watch = False

    try:
        directory = sys.argv[1]
        if '-o' in sys.argv:
            o_index = sys.argv.index('-o')
            output_file = sys.argv[o_index + 1]
        if '-w' in sys.argv:
            watch = True
    except (IndexError, ValueError):
        print("Usage: script.py <directory_path> [-o output_file_path] [-w]")
        sys.exit(1)

    list_files_and_contents(directory, output_file)

    if watch:
        event_handler = ChangeHandler(directory, output_file, list_files_and_contents)
        observer = Observer()
        observer.schedule(event_handler, directory, recursive=True)
        observer.start()
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            observer.stop()
        observer.join()

if __name__ == "__main__":
    main()
